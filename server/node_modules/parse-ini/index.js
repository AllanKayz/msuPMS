const fs = require('fs');
const util = require('util');

var logdebug = util.debuglog('debug');
var logStripLineEndings = util.debuglog('stripLineEndings');
var logExtractProperty = util.debuglog('extractProperty');
var logExtractProperties = util.debuglog('extractProperties');

var currentIniSection = null;
var regexOfComment = /^\s*;/;
var regexOfSection = /^\s*\[(.+)\]\s*/;
var regexOfProperty = /(.+)=(.*)/;

function isLineDelimiter(s) {
  return line == '\r' || line == '\n' || line == '\r\n';
}

function dismissBlankLines(stringArr) {
  var nonemptyStringArr = [];
  for (line of stringArr) {
    if (line && !isLineDelimiter(line)) nonemptyStringArr.push(line);
  }
  return nonemptyStringArr;
}

function stripLineEndings (stringArr) {
  var clearedLines = [];
  for (line of stringArr) {
    var buffer = new Buffer(line);
    logStripLineEndings('buffer is', buffer);
    var currentIndex = buffer.length - 1;
    while (currentIndex >= 0) {
      var charCode = buffer[currentIndex];
      if (charCode == 13 || charCode == 10) {
        --currentIndex;
      } else {
        var clearedBuffer = buffer.slice(0,currentIndex+1);
        logStripLineEndings('clearedBuffer', clearedBuffer);
        var bufStringRepresentation = clearedBuffer.toString();
        clearedLines.push(bufStringRepresentation);
        break;
      }
    }
  }

  return clearedLines;
}

function isLineTypeSection(line) {
  if (line.match(regexOfSection)) return true;
  return false;
}

function isLineTypeProperty(line) {
  if (line.match(regexOfProperty)) return true;
  return false;
}

function isLineTypeComment(line) {
  if (line.match(regexOfComment)) return true;
  return false;
}

function extractSection(line) {
  var match = line.match(regexOfSection);
  return match[1];
}

function extractProperty(line) {
  logExtractProperty('extractProperty line:', line);
  var match = line.match(regexOfProperty);
  if (match) {
    var result = {};
    result.key = match[1].trim();
    result.value = match[2].trim();
    logExtractProperty('variable is:', result);
    return result;
  } else {
    return null;
  }
}

function extractProperties (lines) {
  var props = {};
  for (line of lines) {
    logExtractProperties('line:', line);
    if (isLineTypeComment(line)) {
      logExtractProperties('is a comment');
      // comments are not processed
    } else if (isLineTypeSection(line)) {
      logExtractProperties('is a section');
      currentIniSection = extractSection(line);
      logExtractProperties('currentIniSection:', currentIniSection); 
      if (!props[currentIniSection + '']) props[currentIniSection + ''] = {};
    } else if (isLineTypeProperty(line)) {
      logExtractProperties('is a property');
      var prop = extractProperty(line);
      if (prop) {
        if (currentIniSection) { 
          // variable is added to the section properties
          props[currentIniSection][prop.key] = prop.value;
        } else {
          // variable is added to the global properties
          props[prop.key] = prop.value;
        }
      }
    }
  }
  
  return props;
}

module.exports = {
  parse: function (file) {
    const fileContent = fs.readFileSync(file);
    parsed = this.parseString(fileContent.toString());
    return parsed;
  },
  
  parseString: function (iniString) {
    logdebug('iniString:\n' + iniString);
    var lines = iniString.split('\n');
    lines = dismissBlankLines(lines);
    logdebug('non-blank ini lines:\n', lines);
    lines = stripLineEndings(lines);
    logdebug('cleared ini lines:\n', lines);
    var props = extractProperties(lines);
    logdebug('props:', props);

    return props;
  }
}
